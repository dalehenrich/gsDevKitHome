TDScriptLeafNode{#name:'installSoldierClass',#contents:'[ :topez :objIn :tokens :command :commandNode | 
  | opts args |
  \"for help: ./installSoldierClass -h\"
  command
    getOptsMixedLongShort: {#(\'help\' $h #\'none\')}
    optionsAndArguments: [ :options :operands | 
      opts := options.
      args := operands ].
  opts
    at: \'help\'
    ifAbsent: [ 
      | cls1 cls2 cls3 |
      cls1 := Object
        subclass: #\'Soldier\'
        instVarNames: #(#\'name\' #\'rank\')
        classVars: #(#\'Ranks\')
        classInstVars: #()
        poolDictionaries: #()
        inDictionary: UserGlobals.
      cls1 category: \'Selector-PathTerm-Example\'.
      cls1 compileMissingAccessingMethods.
      cls1 class
        compile:
            \'initialize
| index |
Ranks := SymbolKeyValueDictionary new.
index := 1.
#( #Lieutenant #Captain #Major #Colonel #General )
\tdo: [:e | Ranks at: e put: index.
\t\tindex := index + 1 ].\';
        compile:
            \'rankOrderForRank: aSymbol
^ (Ranks at: aSymbol otherwise: 0)\';
        yourself.
      cls1 initialize.
      cls1
        compile:
            \'rankOrder
^self class rankOrderForRank: rank.\';
        compile:
            \'printOn: aStream
aStream nextPutAll: self rank asString.
aStream nextPut: $ .
aStream nextPutAll: self name asString.\';
        compile:
            \'oldPromoteTo: newRank
\"Promote the receiver to the given rank.\"
| anArray |
anArray := self removeObjectFromBtrees.
rank := newRank.
self addObjectToBtreesWithValues: anArray\';
        compile:
            \'promoteTo: newRank
rank := newRank\';
        yourself.
      cls2 := Object
        subclass: #\'SoldierModificationTracker\'
        instVarNames: #(#\'trackedOffset\' #\'selectorPathTerm\')
        classVars: #()
        classInstVars: #()
        poolDictionaries: #()
        inDictionary: UserGlobals.
      cls2 category: \'Selector-PathTerm-Example\'.
      cls2 compileMissingAccessingMethods.
      cls2
        compile:
            \'btreeAt: anObject put: ar
  | newKey indexObj vals |
  newKey := anObject rankOrder.
  indexObj := ar at: 1.
  vals := ar at: 2.
  vals do: [ :val | indexObj btreeAt: newKey put: anObject ]\';
        compile:
            \'modifyingObject: anObject atOffset: anOffset to: newKey
  | pathTerm vals |
  anOffset == self trackedOffset
    ifFalse: [ ^ self ].
  pathTerm := self selectorPathTerm.
  vals := {}.
  1 to: pathTerm size do: [ :j | 
    | indexObj |
    \" for each index utilizing this path term \"
    indexObj := pathTerm at: j.
    vals
      add:
        {indexObj.
        (self updateIndex: indexObj forKeysWithValue: anObject toNewKey: newKey)} ].
  ^ vals\';
        compile:
            \'updateIndex: indexObj forKeysWithValue: anObject toNewKey: newValue
  | aKey stream vals spec |
  \" first we need to find all values that have aKey as the key \"
  aKey := anObject
    perform:
      (selectorPathTerm name copyFrom: 2 to: selectorPathTerm name size) asSymbol.
  stream := indexObj asQueryEvaluator
    _findAllValuesGreaterThanKey: aKey
    andEquals: true.
  vals := {}.
  [ stream _btreeAtEnd not and: [ stream _peekKey _idxForSortEqualTo: aKey ] ]
    whileTrue: [ 
      aKey == stream _peekKey 
        ifTrue: [ 
          | peeked |
          \"pick out the values at the given key that are identical to anObject\"
          peeked := stream _peekValue.
          peeked == anObject
            ifTrue: [ vals add: peeked ] ].
      stream _btreeNext ].
  spec := {}.
  1 to: vals size do: [ :i | 
    \"remove the entry for each old value \"
    spec add: (vals at: i).
    indexObj btreeRemoveKey: aKey value: (vals at: i) ].
  ^ spec\';
        yourself.
      cls3 := Object
        subclass: #\'SoldierNscModificationTracker\'
        instVarNames: #(#\'selectorModificationTracker\')
        classVars: #()
        classInstVars: #()
        poolDictionaries: #()
        inDictionary: UserGlobals.
      cls3 category: \'Selector-PathTerm-Example\'.
      cls3 compileMissingAccessingMethods.
      cls3
        compile:
            \'adding: newObject to: trackedObject
  \"add a dependency to the soldier modification tracker, so that changes to the 
   object that affect the selector-based index can be tracked\"

  newObject _setModificationTrackingTo: self selectorModificationTracker\';
        compile:
            \'removing: anObject from: trackedObject
  anObject _clearModificationTrackingTo: self selectorModificationTracker\';
        yourself ]
    ifPresent: [ :ignored | 
      TDManPage
        viewManPage:
          \'NAME
  installSoldierClass - installSoldierClass sript utility template
SYNOPSIS
  installSoldierClass [-h|--help]
DESCRIPTION
EXAMPLES
  ./installSoldierClass --help
  ./installSoldierClass -h
\'
        topez: topez ] ]',#creationTime:DateAndTime['2015-04-30T11:08:20.3978600502014-07:00'],#modificationTime:DateAndTime['2015-04-30T21:06:08.3763110637664-07:00']}